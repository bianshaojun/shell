# shellNote
## day2

* 探查进程--ps

	默认情况下,只显示运行在当前控制台下的当前用户的进程;

	参数有很多,没必要全部记住,记住常用的就行,必要时在查询help手册;

	* ps -ef

		查看系统上运行的所有进程;

		-e--显示所有运行在系统上的进程;

		-f--扩展了输出其他有用信息;
		
		* UID--启动这些进程的用户;
		
		* PID--进程的进程ID;
		
		* PPID--父进程的进程号,(如果该进程是由另一个进程启动的);
		
		* C--进程生命周期中的CPU利用率;
		
		* STIME--进程启动时的系统时间;
		
		* TTY--进程启动时的终端设备;
		
		* TIME--运行进程需要的累计CPU时间;
		
		* CMD--启动的程序名称;

	* ps -l

		输出比-f更多的信息;

		* F--内核分配给进程的系统标记;
	
		* S--进程的状态(O代表正在运行,S)

		* PRI--进程的优先级,数字越大优先级越低;

		* NI--谦让度值用来参与决定优先级;

		* ADDR--进行的内存地址;

		* SZ--假如进程被换出,所交换空间的大致大小;

		* WCHAN--进程休眠的内核函数的地址;	

	* ps --forest

		显示进程层级信息;

	* ps -aux

		显示所有包含其他使用者的进程;

* 实时监测进程--top

	显示进程信息,实时显示;

	默认情况下,按照%CPU值进行排序,键入f允许选中对输出进行排序的字段,键入d允许修改轮询间隔,键入q退出;

* 结束进程--kill,killall

	* kill

		通过进程ID(PID)给进程发信号,默认发送TERM信号;

		强制终止,可以使用-s来指定其他信号;

		`kill -s KILL or kill -s 9 or kill -9`

	* killall

		通过进行名来结束进程,支持通配符;

	* linux进程信号

| 信号 | 名称 | 描述 |
| ---- | ---- | ---- |
| 1 | HUP | 挂起 |
| 2 | INT | 中断 |
| 3 | QUIT | 结束运行 |
| 9 | KILL | 无条件终止 |
| 11 | SEGV | 段错误 | 
| 15 | TERM | 尽可能终止 | 
| 17 | STOP | 无条件停止运行,但不终止 |
| 18 | TSTP | 停止或暂停,但继续在后台运行 | 
| 19 | CONT | 在STOP或TSTP之后恢复执行 | 

* 挂载存储媒体--mount

	默认情况下,mount输出当前系统上挂载的设备列表;

	* 挂载命令

		`mount -t type device directory`

		type参数指定文件系统类型;

	* 卸载命令

		`umount [directory | device]`

* 查看磁盘空间--df

	显示每个有数据的已挂载文件系统;

	* -h参数
	
		会把输出的磁盘空间用M,G来显示用户易读的形式;

* 磁盘使用情况-du

	显示某个特定目录(默认情况下是当前目录)的磁盘使用情况;

	* -c参数

		显示所有已列出文件总的大小;
	* -h参数

		按用户易读的格式输出大小;
	* -s参数

		显示每个输出参数的总计;

* 排序数据--sort

	对数据进行排序,默认情况下按照默认语言的排序规则排序;

	* -n参数

		把数字识别成数字,按值进行排序;

	* -M参数

		按月排序;
	* -t,-k参数

		-t参数来指定字段分隔符;

		-k参数来指定排序的字段;
	* -r参数

		将结果按降序输出;

* 搜索数据--grep

	`grep [options] pattern [file]` 

	在输入或指定的文件中查找包含匹配指定模式的字符的行;

	* -v参数

		反向搜索,输出不匹配该模式的行;

	* -n参数

		显示匹配模式的行所在的行号;
	
	* -c参数

		显示有多少行含有匹配的模式;

	* -e参数

		指定多个匹配模式;

		`grep -e t -e f file`--在file中搜索含有t或f的行,这中也可以利用正则表达式来实现,`grep [tf] file`;

* 压缩数据--gzip

	* gzip--用来压缩文件;

	* gzcat--用来查看压缩过的文本文件的内容;

	* gunzip--用来解压文件;

* 归档数据--tar

	`tar function [options] object1 object2 ...`

	* -cvf参数

		创建一个归档文件;

		`tar -cvf test.tar test/ test2/`

	* -tf参数

		列出tar文件的内容,但不提取;

		`tar -tf test.tar`

	* -xvf参数

		提取文件内容;

		`tar -xvf test.tar`

	* -z参数

		将输出重定向给gzip命令来压缩内容;

		`tar -zxvf ...`	--提取文件内容;

		`tar -zcvf ...` --归档文件内容;

	* -j参数

		将输出重定向给bzip2命令来压缩内容;

		`tar -jxvf ...`	--提取文件内容;

		`tar -jcvf ...` --归档文件内容;
	
	* tar命令的功能和选项
	
| 功能 | 描述 |
| ---- | ---- |
| -A | --concatenate 将一个已有tar归档文件追加到另一个已有tar归档文件 | 
| -c | --create 创建一个新的tar归档文件 |
| -d | --diff 检查归档文件和文件系统的不同之处 <br> --delete 从已有tar归档文件中删除 |
| -r | --append 追加文件到已有tar归档文件末尾 |
| -t | --list 列出已有tar归档文件的内容 |
| -u | --update 将比tar归档文件中已有的同名文件新的文件追加到该tar归档文件中 |
| -x | --extract 从已有tar归档文件中提取文件 |

| 选项 | 描述 | 
| --- | --- |
| -C dir | 切换到指定目录 | 
| -f file | 输出结果到文件或设备file |
| -j | 将输出重定向给bzip2命令来压缩内容 | 
| -p | 保留所有文件权限 |
| -v | 在处理文件时显示文件 | 
| -z | 将输出重定向给gzip命令来压缩内容 |

* 进程列表

	将命令放在括号内,就成为了进程列表;

	进程列表生成一个子shell来执行对应的命令;

* echo命令

	将指定字符串输出到STDOUT;

* sleep命令

	在指定的一段时间内暂停bash shell操作;

	`sleep 10`--暂停10s;

* jobs命令

	显示当前运行在后台模式中的所有用户的进程;

	* -l参数

		显示命令的PID;

* 后台运行--&

	将命令置入后台模式,可以在命令后加上字符&;

	`sleep 10 &`

* 协程--coproc

	协程可以同时处理两件事,在后台生成一个子shell,并在子shell中执行命令;

	`coproc sleep 10` -- 默认协程的名字为COPROC;

	`coproc My_Job { sleep 10; }` -- 指定协程名字,必须确保在第一个花括号和命令名之间有一个空格,还必须保证命令以分号;结尾,分号和闭花括号之间也得有一个空格;

* which命令

	查找可执行文件的位置;

* type命令

	显示指定的单词如果作为命令将会如何被解释,也可以查找可执行文件的位置;

* history命令

	查看最近用过的命令列表;

	通过设置环境变量HISTSIZE来改变保存的命令数;

	* -a参数

		强制写入.bash_history文件;

	* -n参数

		强制重新读取.bash_history文件,更新终端会话的历史记录;

* !!命令

	执行上一次的命令;

* !num命令

	执行history记录中num编号的命令;

* alias命令

	创建命令别名;

	`alias li='ls - -li'`

	`alias -p` -- 查看当前可用的别名;

* 全局环境变量

	全局环境变量对于shell会话和生成的子shell都是可见的.

	局部变量只对创建它们的shell可见;

	* printenv或env

		查看全局变量;

* 局部环境变量

	* set命令

		显示为某个特定进程设置的所有环境变量;

* 创建环境变量

	`var_name=string`

	引用只需在变量前加$;

* export命令

	导出环境变量,为全局变量,子shell改变其变量值,不会对父shell有影响;

* 删除环境变量

	unset命令删除环境变量,变量不使用$;

	`unset my_variable`	

* PATH环境变量

	定义了用于进行命令和程序查找的目录;

	对PATH变量的修改只能持续到退出或重启系统;

	`PATH=$PATH:/../../../some_dir`

* 环境变量持久化

	可以将新的或修改过的变量设置存放在/etc/profile文件中;
	
	建议最好在/etc/profile.d目录中创建一个以.sh文件结尾的文件,把新的或修改的全局环境变量设置放在这个文件中;

* 数组变量

	`mytest=(one two three four five)`--定义

	`echo ${mytest[2]}`--引用

	`echo ${mytest[*]}`--引用整个数组

	`unset mytest[2]`--删除某个变量,索引2为空,不会显示原来索引3的值;
